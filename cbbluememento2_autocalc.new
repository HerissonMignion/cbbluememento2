#!/bin/guile \
--auto-compile -e main -s
!#

;; TODO: tester les builtin de parsing d'option avec guile

;; TODO: regarder les iterator/generator en srfi ou rnrs


(use-modules
 (ice-9 rdelim)
 (ice-9 regex)
 (ice-9 binary-ports)
 (srfi srfi-11))



(define (print-help)
  (display "TODO: help")
  (newline))


(define (assert-file-exists filepath)
  (unless (access? filepath F_OK)
	(display (format #f "Le fichier n'existe pas: \"~a\"\n" filepath))
	(exit 1)))




(define (print-list-to-stdout lines)
  (let loop ((current-line-cons lines))
	(if (null? current-line-cons)
		#f
		(begin
		  (when (string? (car current-line-cons))
			(display (car current-line-cons))
			(newline))
		  (loop (cdr current-line-cons))))))


(define (make-iter-read-file filename)
  (let ((file-port (open-input-file filename)))
	(values
	 (lambda ()
	   (read-line file-port))
	 (lambda ()
	   (close-port file-port)))))

(define (make-iter-read-list list)
  (let ((next-cons list))
	(values
	 (lambda ()
	   (if (null? next-cons)
		   (eof-object)
		   (let ((ret (car next-cons)))
			 (set! next-cons (cdr next-cons))
			 ret))))))


;; proc est appelé avec (elem, previous).
(define (iter-fold proc init next-proc)
  (let loop ((ret init))
	(let ((val (next-proc)))
	  (if (eof-object? val)
		  (begin ret)
		  (begin
			(loop (proc val ret)))))))

;; returns false si la fin de l'itérateur a été atteint
(define (iter-forward-while predicate next-proc)
  (let loop ()
	(let ((current-value (next-proc)))
	  (if (eof-object? current-value)
		  #f
		  (if (predicate current-value)
			  (loop)
			  #t)))))

(define (iter-forward-until predicate next-proc)
  (iter-forward-while (lambda (value) (not (predicate value))) next-proc))


;; retourne une liste de string de toutes les weeks
(define (list-weeks read-line-iter)
  (reverse
   (iter-fold
	(lambda (current-line ret)
	  (if (string-prefix? "* " current-line)
		  (cons (string-drop current-line 2) ret)
		  ret))
	'()
	read-line-iter)))

(define (list-weeks-from-file filepath)
  (let-values (((read-line-iter close-file) (make-iter-read-file filepath)))
	(let ((ret (list-weeks read-line-iter)))
	  (close-file)
	  ret)))

(define (file-contains-week? filename week-name)
  (let-values (((read-line-iter close-file) (make-iter-read-file filename)))
	(let ((ret (iter-forward-until
				(lambda (line)
				   (string=? line (string-append "* " week-name)))
				read-line-iter)))
	  (close-file)
	  ret)))







;; retourne la liste des lignes qui composent cette week dans le
;; fichier.  exclus la déclaration de la week et la déclaration de
;; la week suivante (exclus les lignes commençant par "* ").
(define (get-week filename week-name)
  ;; TODO: optimiser le check ici pour ne pas lire le fichier 2 fois.
  (if (not (file-contains-week? filename week-name))
	  #f
	  (let-values (((read-line-iter close-file) (make-iter-read-file filename)))
		(let ((reversed-week-lines '()))
		  (iter-forward-until
		   (lambda (current-line)
			 (string=? current-line (string-append "* " week-name)))
		   read-line-iter)

		  (iter-forward-until
		   (lambda (current-line)
			 (if (string-prefix? "* " current-line)
				 (begin #t)
				 (begin
				   (set! reversed-week-lines (cons current-line reversed-week-lines))
				   #f)))
		   read-line-iter)

		  (close-file)
		  (reverse reversed-week-lines)))))



(define (week-has-section? week-lines section-name)
  (let-values (((read-line-iter) (make-iter-read-list week-lines)))
	(iter-forward-until
	 (lambda (current-line)
	   (string=? current-line (string-append "** " section-name)))
	 read-line-iter)))



;; retourne un section dans une semaine (délimité par une ligne
;; commençant par "** "). il faut seulement passer les ligne de la
;; semaine, et non pas tout le fichier.
(define (get-week-section week-lines section-name)
  (if (not (week-has-section? week-lines section-name))
	  #f
	  (let-values (((read-line-iter) (make-iter-read-list week-lines)))
		(let ((reversed-section-lines '()))
		  (iter-forward-until
		   (lambda (current-line)
			 (string=? current-line (string-append "** " section-name)))
		   read-line-iter)

		  (iter-forward-until
		   (lambda (current-line)
			 (if (string-prefix? "** " current-line)
				 (begin #t)
				 (begin
				   (set! reversed-section-lines (cons current-line reversed-section-lines))
				   #f)))
		   read-line-iter)

		  (reverse reversed-section-lines)))))



(define (command-list . args)
  (unless (>= (length args) 1)
	(display "You must provide a file\n")
	(exit 1))
  (let ((filepath (car args)))
	(assert-file-exists filepath)
	(let-values (((read-line-iter close-file) (make-iter-read-file filepath)))
	  (print-list-to-stdout
	   (list-weeks read-line-iter))
	  (close-file))))




(define (autocalc-week-section section-lines)
  (let ((reversed-args '("group" "cbbluememento2")))
	(let-values (((read-line-iter) (make-iter-read-list section-lines)))
	  (let ((is-first-time? #t)
			(period-name #f))
		(iter-fold
		 (lambda (current-line _)
		   (cond
			;; MAYBE TODO: mettre un warning si les minutes dépasse 59
			((string-match "^ *- [0-9]?[0-9]:[0-9][0-9] *$" current-line)
			 (let ((extracted-time (match:substring
									(string-match "^ *- ([0-9]?[0-9]:[0-9][0-9]) *$"
												  current-line) 1)))
			   (if is-first-time?
				   (set! reversed-args (cons* extracted-time "-s" reversed-args))
				   (set! reversed-args (cons* extracted-time
											  (or period-name "noname")
											  "-z"
											  reversed-args))))
			 
			 (set! is-first-time? #f)
			 (set! period-name #f))

			;; MAYBE TODO: améliorer les regex ici?
			((string-match "^ *- .*$" current-line)
			 (when (not period-name)
			   (set! period-name
					 (match:substring (string-match "^ *- ([^ ]*\\b)" current-line)
									  1)))))
		   #t)
		 #t
		 read-line-iter)
		(apply system* (reverse reversed-args))
		(newline)))))


(define (autocalc-week week-lines)
  (for-each
   (lambda (section-name)
	 (when (week-has-section? week-lines section-name)
	   (display "==== ==== ")
	   (display section-name)
	   (newline)
	   (let ((section-lines (get-week-section week-lines section-name)))
		 (autocalc-week-section section-lines))))
   '("dimanche"
	 "lundi"
	 "mardi"
	 "mercredi"
	 "jeudi"
	 "vendredi"
	 "samedi")))



(define (command-autocalc . args)
  (unless (>= (length args) 2)
	(display "You must provide a file and a week name\n")
	(exit 1))
  (let ((filepath (car args))
		(week-name (cadr args)))
	(assert-file-exists filepath)
	(if (not (file-contains-week? filepath week-name))
		(begin
		  (display (format #f "La semaine \"~a\" n'existe pas.\n" week-name))
		  (exit 1))
		(begin
		  (let ((week-lines (get-week filepath week-name)))
			(display "==== ")
			(display week-name)
			(newline)
			(autocalc-week week-lines))))))

(define (command-autocalc-all . args)
  ;; TODO: réécrire pour ne pas être quadratique, si j'en ai besoin un
  ;; jour.
  (unless (>= (length args) 1)
	(display "You must provide a file.\n")
	(exit 1))
  (let ((filepath (car args)))
	(assert-file-exists filepath)
	(for-each
	 (lambda (week-name)
	   (display "==== ")
	   (display week-name)
	   (newline)
	   (autocalc-week (get-week filepath week-name)))
	 (list-weeks-from-file filepath))))


(define (main . _)
  (let ((args (cdr (command-line)))
		(trailing-args (list))
		(opt-all #f))
	(let loop-args ((args-left args))
	  (unless (null? args-left)
		(let ((current-arg (car args-left)))
		  (cond
		   ((string=? current-arg "--")
			(set! trailing-args (append trailing-args (cdr args-left)))
			(loop-args '()))
		   (else
			(cond
			 ((string=? current-arg "--help")
			  (print-help)
			  (exit 0))
			 ((string=? current-arg "--all")
			  (set! opt-all #t))
			 (else
			  (set! trailing-args (append trailing-args (list current-arg)))))
			(loop-args (cdr args-left)))))))

	(cond
	 ((<= (length trailing-args) 0)
	  (display "You must provide a command\n")
	  (exit 1))
	 (else
	  (let ((command (car trailing-args))
			(command-args (cdr trailing-args)))
		(cond
		 ((string=? command "list")
		  (apply command-list command-args))
		 ((string=? command "autocalc")
		  (if opt-all
			  (apply command-autocalc-all command-args)
			  (apply command-autocalc command-args)))
		 (else
		  (display (format #f "Unknown command: ~a\n" command))
		  (exit 1))))))))





